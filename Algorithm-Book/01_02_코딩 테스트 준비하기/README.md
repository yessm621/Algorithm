# 정리

## 01. 어떤 알고리즘으로 풀어야 할까?

코딩 테스트의 핵심 중 하나는 문제마다 주어진 `시간 복잡도`를 고려해 적절한 알고리즘을 선택하는 것이다.

### 01-1. 시간 복잡도 표기법 알아보기

알고리즘에서 **시간 복잡도는 주어진 문제를 해결하기 위한 연산 횟수**를 말한다. 수행 시간은 1억 번의 연산을 1초의 시간으로 간주하여 예측한다.

**시간 복잡도 유형**

- 빅-오메가: 최선일 때의 연산 횟수를 나타낸 표기법
- 빅-세타: 보통일 때의 연산 횟수를 나타낸 표기법
- `빅-오`: 최악일 때(worst case)의 연산 횟수를 나타낸 표기법

```java
public class timeComplexityExample1 {
    public static void main(String[] args) {
        int findNumber = (int) (Math.random() * 100);
        for (int i = 0; i < 100; i++) {
            if (i == findNumber) {
                System.out.println("i = " + i);
                break;
            }
        }
    }
}
```

위 코드의 시간 복잡도를 유형별로 나타내면 아래와 같다.

- 빅-오메가의 시간 복잡도: 1
- 빅-세타의 시간 복잡도: N/2번
- 빅-오의 시간 복잡도: N

코딩 테스트에서는 `빅-오 표기법`을 기준으로 수행 시간을 계산해야 한다. 코딩 테스트에선 응시자가 작성한 프로그램으로 다양한 테스트 케이스를 수행해 모든 케이스를 통과해야 합격으로 판단한다. 따라서, 시간 복잡도를 판단할 때 worst case를 생각해야 한다. 

**빅-오 표기법의 시간 복잡도**

왼쪽으로 갈수록 빠르고 오른쪽으로 갈수록 느리다.

```
O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n) < O(n!)
```

### 01-2. 시간 복잡도 활용하기

앞서 배운 내용을 바탕으로 시간 복잡도의 개념을 코딩 테스트에 활용해보자.

알고리즘을 선택하기 위한 기준을 알기 위해 다음과 같은 가정을 하겠다.

가정
- 버블 정렬과 병합 정렬의 시간 복잡도를 알고 있다.
  - 버블 정렬: O(n^2)
  - 병합 정렬: O(nlogn)

문제
- N개의 수가 주어졌을 때 이를 오름차순 정렬하는 프로그램을 작성하시오.
- 입력: N(1 <= N <= 1,000,000)
- 시간 제한: 2초

문제에서 주어진 시간 제한과 데이터 크기를 바탕으로 어떤 정렬 알고리즘을 사용할지 판단할 수 있다. 시간 제한이 2초이므로 2억 번 이하의 연산횟수로 문제를 해결해야 한다.

**연산 횟수 계산 방법**
```
연산 횟수 = 알고리즘 시간 복잡도 * 데이터의 크기
```

- 버블 정렬 = (1,000,000)^2 -> 2억 번을 초과하므로 부적합 알고리즘
- 병합 정렬 = 1,000,000log(1,000,000) -> 2억 번을 초과하지 않으므로 적합 알고리즘

시간 복잡도는 작성한 코드의 비효율적인 로직을 개선하는 바탕으로도 사용할 수 있는데 이를 활용하려면 시간 복잡도를 추출할 수 있어야 한다.

시간 복잡도 도출 기준
- 상수는 시간 복잡도 계산에서 제외한다.
- 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.

아래 예제 코드의 연산 횟수는 2배의 차이가 난다. 하지만, 코딩 테스트에서 일반적으로 상수는 무시하므로 두 코드의 시간 복잡도는 O(n)으로 같다.
```java
public class 시간복잡도_판별1 {
    public static void main(String[] args) {
        int N = 100000;
        for (int i = 0; i < N; i++) {
            ...
        }
    }
}
```
```java
public class 시간복잡도_판별2 {
    public static void main(String[] args) {
        int N = 100000;
        for (int i = 0; i < N; i++) {
            ...
        }
        for (int i = 0; i < N; i++) {
            ...
        }
    }
}
```

또한, 시간 복잡도는 가장 많이 중첩된 반복문을 기준으로 도출하므로 O(n^2)이 된다.
```java
public class 시간복잡도_판별3 {
    public static void main(String[] args) {
        int N = 100000;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                ...
            }
        }
        for (int i = 0; i < N; i++) {
            ...
        }
    }
}
```

이처럼 자신이 작성한 코드에 대한 시간 복잡도를 도출할 수 있으면 실제 코딩 테스트에서 시간 초과가 발생했을 때 문제되는 부분을 도출하고 더욱 효율적인 코드로 수정하는 작업으로 문제를 해결할 수 있다.

## 02. 코드의 논리 오류를 어떻게 잡을까?

코드의 논리 오류를 찾을 수 있는 가장 최선의 방법은 디버깅이다.

### 02-1. 디버깅은 왜 중요할까?

디버깅이란 프로그램에서 발생하는 문법 오류나 논리 오류를 찾아 바로잡는 과정을 말한다.

문법 오류는 컴파일러가 자동으로 찾아준다. 논리 오류는 개발자의 의도와 다르게 동작하는 것이며 다양한 형태로 발생한다.

### 02-2. 디버깅 활용 사례

디버깅은 코딩 테스트 시 꼭 필요한 작업이다. 테스트 코드에서 가장 많이 실수하는 부분은 디버깅으로 찾을 수 있다.

테스트 코드에서 가장 많이 실수하는 부분
- 변수 초기화
- 반복문에서 인덱스 범위 지정 오류
- 잘못된 변수 사용 (변수명 혼동)
- 자료형 범위 오류

앞서 소개한 4가지 실수 중 가장 하기 쉬운 실수는 자료형 범위 오류이다. 자료형은 처음부터 long형으로 선언하는 것이 좋다. 대부분의 코딩 테스트에서 계산되는 값은 long형으로 충분하다.